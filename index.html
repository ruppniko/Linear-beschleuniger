<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>LINAC Game</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f9f9f9;
    }
    canvas {
      border: 1px solid #333;
      background: #fff;
      display: block;
      margin: 20px auto;
    }
    h1 {
      color: darkmagenta;
    }
    button {
      padding: 8px 16px;
      margin-top: 10px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>üéÆ Hochfrequenz-Linearbeschleuniger (LINAC) ‚Äì Simulator</h1>
  <p>Klicke auf eine Driftr√∂hre, um ihre Polung zu wechseln, oder die position zu √§ndern!</p>
  <canvas id="linacCanvas" width="1000" height="200"></canvas>
  <p><strong>Geschwindigkeit:</strong> <span id="score">0</span> | <strong>Highscore:</strong> <span id="highscore">0</span></p>
  <div class="controls">
    <button onclick="reset()">Reset</button>
    <button onclick="switchAllPolarities()">Alle Polarit√§ten wechseln</button>
    <label><input type="checkbox" id="autoPol"> Auto-Polung aktivieren</label>
    <input type="range" id="autoPolFreq" value="2" min="0.1" max="5" step="0.1" style="width:120px; vertical-align:middle;">
    <span id="autoPolFreqLabel">2.0 Hz</span>
    <button onclick="addTube()">R√∂hre hinzuf√ºgen</button>
    <button onclick="removeTube()">R√∂hre entfernen</button>
  </div>
  <br>

  <script>
    const canvas = document.getElementById("linacCanvas");
    const ctx = canvas.getContext("2d");

    const tubeCount = 4;
    const tubeWidth = 20; // k√ºrzere R√∂hren
    const gapWidth = 100; // Abstand f√ºr Beschleunigungsstrecke
    const tubeHeight = 80;
    let tubes = [];

    const offsetX = 100;

    let particle = {
      x: offsetX - 20,
      y: canvas.height / 2,
      radius: 10,
      v: 1
    };

    let score = 0;
    let highscore = parseInt(localStorage.getItem("linacHighscore")) || 0;
    document.getElementById("highscore").textContent = highscore;

    // Initialisiere R√∂hren
    for (let i = 0; i < tubeCount; i++) {
      tubes.push({
        x: offsetX + i * (tubeWidth + gapWidth),
        polarity: i % 2 === 0 ? -1 : 1
      });
    }

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      tubes.forEach((tube) => {
        if (
          mx >= tube.x &&
          mx <= tube.x + tubeWidth &&
          my >= particle.y - tubeHeight / 2 &&
          my <= particle.y + tubeHeight / 2
        ) {
          tube.polarity *= -1;
        }
      });
    });

    // Drag-and-drop Variablen
    let draggingTube = null;
    let dragOffsetX = 0;

    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      for (let tube of tubes) {
        if (
          mx >= tube.x &&
          mx <= tube.x + tubeWidth &&
          my >= particle.y - tubeHeight / 2 &&
          my <= particle.y + tubeHeight / 2
        ) {
          draggingTube = tube;
          dragOffsetX = mx - tube.x;
          break;
        }
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      if (draggingTube) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        draggingTube.x = Math.max(0, Math.min(canvas.width - tubeWidth, mx - dragOffsetX));
      }
    });

    canvas.addEventListener("mouseup", () => {
      draggingTube = null;
    });

    function addTube() {
      // F√ºge eine neue R√∂hre rechts an
      const lastX = tubes.length > 0 ? tubes[tubes.length - 1].x + tubeWidth + 80 : offsetX;
      tubes.push({
        x: lastX,
        polarity: tubes.length % 2 === 0 ? -1 : 1
      });
    }

    function removeTube() {
      if (tubes.length > 0) tubes.pop();
    }

    let autoPolFreq = 2; // Hz
    let autoPolFrameCount = 0;
    let framesPerSwitch = Math.round((1 / autoPolFreq) * 60 / 2); // 60 FPS, 2x pro Periode

    function update() {
      tubes.forEach((tube, i) => {
        const nextX = i < tubes.length - 1 ? tubes[i + 1].x : canvas.width;
        const accelZoneStart = tube.x + tubeWidth;
        const accelZoneEnd = nextX;

        // Bestimme, ob das Teilchen im Beschleunigungsbereich zwischen zwei R√∂hren ist
        if (particle.x >= accelZoneStart && particle.x <= accelZoneEnd) {
          // Linke und rechte R√∂hre im aktuellen Beschleunigungsbereich
          const leftPolarity = tube.polarity;
          const rightPolarity = i < tubes.length - 1 ? tubes[i + 1].polarity : null;

          if (rightPolarity !== null) {
            const distance = Math.abs(nextX - (tube.x + tubeWidth));
            // Normiere die Beschleunigung auf eine Basisdistanz, z.B. 100px
            const baseAccel = 0.05;
            const baseDistance = 100;
            const accel = baseAccel * (baseDistance/distance);

            if (leftPolarity === 1 && rightPolarity === -1) {
              // Beschleunigung: links positiv, rechts negativ
              particle.v += accel;
            } else if (leftPolarity === -1 && rightPolarity === 1) {
              // Abbremsen: links negativ, rechts positiv
              particle.v -= accel;
            }
            // Sonst keine √Ñnderung
          }
        }
      });

      // Auto-Polung √ºber Frame-Z√§hler
      if (document.getElementById("autoPol").checked) {
        autoPolFrameCount++;
        if (autoPolFrameCount >= framesPerSwitch) {
          tubes.forEach((tube) => {
            tube.polarity *= -1;
          });
          autoPolFrameCount = 0;
        }
      }

      particle.x += particle.v;
      // Allow negative velocity, but clamp to a minimum (e.g., -10)
      if (particle.v < -10) particle.v = -10;

      score = Math.floor(particle.v * 100);
      document.getElementById("score").textContent = score;

      if (particle.x > canvas.width - 20) {
        if (score > highscore) {
          localStorage.setItem("linacHighscore", score);
          alert("üèÜ Neuer Highscore: " + score);
          highscore = score;
        }
        reset();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Teilchenquelle
      ctx.fillStyle = "magenta";
      ctx.fillRect(offsetX - 60, particle.y - 30, 40, 60);

      // R√∂hren
      tubes.forEach((tube) => {
        ctx.fillStyle = tube.polarity === -1 ? "#cce5ff" : "#ffcccc";
        ctx.fillRect(tube.x, particle.y - tubeHeight / 2, tubeWidth, tubeHeight);
        ctx.strokeStyle = "black";
        ctx.strokeRect(tube.x, particle.y - tubeHeight / 2, tubeWidth, tubeHeight);

        ctx.fillStyle = "black";
        ctx.font = "20px sans-serif";
        ctx.fillText(tube.polarity === 1 ? "+" : "-", tube.x + tubeWidth / 2 - 5, particle.y + 7);
      });

      // Teilchen
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, particle.radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.font = "14px sans-serif";
      ctx.fillText("+", particle.x - 4, particle.y + 5);
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function resetTubePolarities() {
      // Setze R√∂hren auf Start-Polarit√§t (abwechselnd -1/+1)
      tubes.forEach((tube, i) => {
        tube.polarity = i % 2 === 0 ? -1 : 1;
      });
    }

    function reset() {
      particle.x = offsetX - 20;
      particle.v = 1;
      score = 0;
      document.getElementById("score").textContent = score;
      highscore = parseInt(localStorage.getItem("linacHighscore")) || 0;
      document.getElementById("highscore").textContent = highscore;
      // Nur wenn Auto-Polung aktiv ist, Phase zur√ºcksetzen
      if (document.getElementById("autoPol").checked) {
        resetTubePolarities();
        autoPolFrameCount = 0;
      }
    }

    function switchAllPolarities() {
      tubes.forEach(tube => tube.polarity *= -1);
    }

    // Checkbox-Listener f√ºr Auto-Polung
    document.getElementById("autoPol").addEventListener("change", function() {
      if (this.checked) {
        // startAutoPol();
      } else {
        // clearInterval(autoPolInterval);
      }
    });

    // Slider-Listener f√ºr Frequenz
    const autoPolFreqSlider = document.getElementById("autoPolFreq");
    const autoPolFreqLabel = document.getElementById("autoPolFreqLabel");
    autoPolFreqSlider.addEventListener("input", function() {
      autoPolFreqLabel.textContent = parseFloat(this.value).toFixed(1) + " Hz";
      autoPolFreq = parseFloat(this.value) || 2;
      framesPerSwitch = Math.round((1 / autoPolFreq) * 60 / 2);
      autoPolFrameCount = 0; // Phase neu starten
    });
    // Initialisiere Label und Frames
    autoPolFreq = parseFloat(autoPolFreqSlider.value) || 2;
    framesPerSwitch = Math.round((1 / autoPolFreq) * 60 / 2);
    autoPolFrameCount = 0;

    loop();
  </script>
</body>
</html>
